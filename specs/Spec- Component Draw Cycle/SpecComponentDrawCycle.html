<html><head><title>Spec: Component Draw Cycle</title></head><body style="max-width:468pt;background-color:#d9d9d9;padding:72pt 72pt 72pt 72pt"><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="font-size:14pt;font-weight:bold">- Draft -</span></p><a href="#" name="83ff02a24c28e0d5a584d38ad1b4ed37534155c1"></a><a href="#" name="0"></a><table cellpadding="0" cellspacing="0" style="border-collapse:collapse"><tbody><tr><td style="vertical-align:top;width:343.5pt;border-style:solid;border-color:#b7b7b7;border-width:1pt;padding:5pt 5pt 5pt 5pt"><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="font-size:18pt;font-weight:bold">Component Draw Cycle</span></p></td><td style="vertical-align:top;width:124.5pt;border-style:solid;border-color:#b7b7b7;border-width:1pt;padding:5pt 5pt 5pt 5pt"><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="vertical-align:super;text-decoration:underline">Editor</span><span>&nbsp;Heather Douglass</span></p></td></tr></tbody></table><p style="height:11pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="font-size:14pt;font-weight:bold"></span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="font-size:14pt;font-weight:bold">Index</span></p><p style="margin-right:0;color:#000000;direction:ltr;font-size:11pt;margin-left:18pt;margin-bottom:0;font-family:&quot;Arial&quot;;margin-top:0;padding:0"><span style="text-decoration:underline"><a href="#h.19uopb757udz" style="color:inherit;text-decoration:inherit">Introduction</a></span></p><p style="margin-right:0;color:#000000;direction:ltr;font-size:11pt;margin-left:18pt;margin-bottom:0;font-family:&quot;Arial&quot;;margin-top:0;padding:0"><span style="text-decoration:underline"><a href="#h.5h0ym5gvhxdq" style="color:inherit;text-decoration:inherit">Functional Description</a></span></p><p style="margin-right:0;color:#000000;direction:ltr;font-size:11pt;margin-left:18pt;margin-bottom:0;font-family:&quot;Arial&quot;;margin-top:0;padding:0"><span style="text-decoration:underline"><a href="#h.rmptzwuxiuua" style="color:inherit;text-decoration:inherit">API</a></span></p><p style="margin-right:0;color:#000000;direction:ltr;font-size:11pt;margin-left:18pt;margin-bottom:0;font-family:&quot;Arial&quot;;margin-top:0;padding:0"><span style="text-decoration:underline"><a href="#h.60rjnnccp5ma" style="color:inherit;text-decoration:inherit">Examples</a></span></p><p style="margin-right:0;color:#000000;direction:ltr;font-size:11pt;margin-left:18pt;margin-bottom:0;font-family:&quot;Arial&quot;;margin-top:0;padding:0"><span style="text-decoration:underline"><a href="#h.9qqs41sdkrcs" style="color:inherit;text-decoration:inherit">Integration</a></span></p><p style="margin-right:0;color:#000000;direction:ltr;font-size:11pt;margin-left:18pt;margin-bottom:0;font-family:&quot;Arial&quot;;margin-top:0;padding:0"><span style="text-decoration:underline"><a href="#h.iud7a9mdzn4" style="color:inherit;text-decoration:inherit">Dependencies</a></span></p><p style="margin-right:0;color:#000000;direction:ltr;font-size:11pt;margin-left:18pt;margin-bottom:0;font-family:&quot;Arial&quot;;margin-top:0;padding:0"><span style="text-decoration:underline"><a href="#h.178na9dwjesv" style="color:inherit;text-decoration:inherit">Concerns</a></span></p><p><span></span></p><h3 style="padding-left:0;padding-right:0;line-height:1.15;padding-top:14pt;color:#000000;text-align:left;direction:ltr;font-size:14pt;margin:0;font-family:&quot;Arial&quot;;font-weight:bold;padding-bottom:4pt"><a name="h.19uopb757udz"></a><span>Introduction</span></h3><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>When building HTML5 applications, especially on mobile, performance is important. &nbsp;One area that can be especially critical is DOM manipulation/reading. &nbsp;Repeatedly manipulating/reading the DOM causing style reflows can slow down an application considerably, even on a desktop machine</span><sup><a href="#ftnt1" name="ftnt_ref1">[1]</a></sup><span>. &nbsp;Montage tries to alleviate this by delaying DOM manipulation in order to batch changes and limit the number of reflows.</span></p><h3 style="padding-left:0;padding-right:0;line-height:1.15;padding-top:14pt;color:#000000;text-align:left;direction:ltr;font-size:14pt;margin:0;font-family:&quot;Arial&quot;;font-weight:bold;padding-bottom:4pt"><a name="h.5h0ym5gvhxdq"></a><span>Functional Description</span></h3><p style="text-indent:36pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>Montage implements delayed DOM manipulation in order to batch changes to the DOM thereby improving performance. &nbsp;This is implemented through a series of callbacks that the framework calls on a component. &nbsp;To participate in this cycle a component should first implement three methods as necessary, </span><span style="font-family:&quot;Courier New&quot;">willDraw</span><span>, </span><span style="font-family:&quot;Courier New&quot;">draw</span><span>&nbsp;and </span><span style="font-family:&quot;Courier New&quot;">didDraw</span><span>. &nbsp;Which methods need to be implemented is dependent on what the component wants to do. &nbsp;The Montage framework will call these methods at the appropriate times. &nbsp;These methods should never be called directly by components. &nbsp;To improve performance there are restrictions about what sort of actions should be taken in each method. &nbsp;First, a component should not perform any DOM manipulation outside of the </span><span style="font-family:&quot;Courier New&quot;">draw</span><span>&nbsp;method. &nbsp;DOM manipulation includes element style changes and/or appending or removing elements from the DOM. &nbsp;Second, any reading of the DOM for measurements, such as </span><span>offsetWidth</span><sup><a href="#cmnt1" name="cmnt_ref1">[a]</a></sup><span>, should only be performed in the </span><span style="font-family:&quot;Courier New&quot;">willDraw</span><span>&nbsp;or </span><span style="font-family:&quot;Courier New&quot;">didDraw</span><span>&nbsp;methods and never in the </span><span style="font-family:&quot;Courier New&quot;">draw</span><span>&nbsp;method. &nbsp;By implementing DOM manipulation/reading for components as described this will limit the amount of reflows by the browser which will help to improve performance.</span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The second thing that a component needs to do when it wants these three methods to be called is to set a property on itself, </span><span style="font-family:&quot;Courier New&quot;">needsDraw</span><span>, to true. &nbsp;Setting this property to true will alert the framework that this component wants to participate in the next draw cycle. &nbsp;Draw cycles are scheduled using either a setTimeout or requestAnimationFrame if it&rsquo;s available.</span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;During a draw cycle the component hierarchy is explored starting from the root component. &nbsp;Only components that have indicated they want to draw or have a child that wants to draw are explored. &nbsp;Components can block exploration of their children by returning false from their </span><span style="font-family:&quot;Courier New&quot;">canDraw</span><sup><a href="#cmnt2" name="cmnt_ref2">[b]</a></sup><span>&nbsp;method. &nbsp; As the component tree is explored a list is built of the components which have set their </span><span style="font-family:&quot;Courier New&quot;">needsDraw</span><span>&nbsp;property to true. &nbsp;As components are added to this list, if this is the first time that the component is being drawn, then the component will have its </span><span style="font-family:&quot;Courier New&quot;">prepareForDraw</span><sup><a href="#cmnt3" name="cmnt_ref3">[c]</a></sup><span>&nbsp;method called. &nbsp;This method is only called the first time a component is participating in a draw cycle. &nbsp;Once the hierarchy has been explored the framework iterates through the generated list calling </span><span style="font-family:&quot;Courier New&quot;">willDraw</span><span>&nbsp;on each component in it. &nbsp;As a result of calling </span><span style="font-family:&quot;Courier New&quot;">willDraw</span><span>&nbsp;on the components in this list other components that are not currently in the list of components to draw may have had their </span><span style="font-family:&quot;Courier New&quot;">needsDraw</span><span>&nbsp;property set to true. &nbsp;Once all the components in the initial list have had </span><span style="font-family:&quot;Courier New&quot;">willDraw</span><span>&nbsp;called on them the component hierarchy is explored again to add any components that need to be drawn as a result of calling </span><span style="font-family:&quot;Courier New&quot;">willDraw</span><span>&nbsp;on the initial list. &nbsp;</span><span style="font-family:&quot;Courier New&quot;">willDraw</span><span>&nbsp;is then called on any newly added components and this process is repeated until no new components have been added to the list of components to draw. &nbsp;After this point any component that has </span><span style="font-family:&quot;Courier New&quot;">needsDraw</span><span>&nbsp;set to true during the remainder of the draw cycle will be part of the next draw cycle. &nbsp;It will not be added to the currently executing cycle. &nbsp;Next, the generated list is sorted by where the component was in the component hierarchy. &nbsp;This is to ensure that child components are always drawn before their parent component. &nbsp;The sorted list is iterated over in reverse order and </span><span style="font-family:&quot;Courier New&quot;">draw</span><span>&nbsp;is called on each component in the list. &nbsp;Last, the same generated list is iterated over again and </span><span style="font-family:&quot;Courier New&quot;">didDraw</span><span>&nbsp;is called on each component in the list. &nbsp;During the iteration if it has been the first draw for any component in the list that component will dispatch a custom event with a type of </span><span style="font-family:&quot;Courier New&quot;">firstDraw</span><span>&nbsp;immediately after its </span><span style="font-family:&quot;Courier New&quot;">didDraw</span><span>&nbsp;method has been called.</span></p><p style="height:11pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span></span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>Debug flag for erroring on DOM manipulation outside of draw</span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>Component loading in relation to draw, canDrawGate API, blockDrawGate API?</span></p><h3 style="padding-left:0;padding-right:0;line-height:1.15;padding-top:14pt;color:#000000;text-align:left;direction:ltr;font-size:14pt;margin:0;font-family:&quot;Arial&quot;;font-weight:bold;padding-bottom:4pt"><a name="h.rmptzwuxiuua"></a><span>API</span></h3><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>On Component</span></p><p style="height:11pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span></span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="font-family:&quot;Courier New&quot;">needsDraw</span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>Set this property to true when the component needs its draw callbacks called</span></p><p style="height:11pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span></span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="font-family:&quot;Courier New&quot;">canDraw()</span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>This method controls whether a component participates in the currently executing draw cycle and whether or not its children are explored when the initial list for a cycle is built. &nbsp;It must return false if the component and its children should not participate in the cycle and true if they should.</span></p><p style="height:11pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span></span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="font-family:&quot;Courier New&quot;">prepareForDraw()</span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>This method can be used to execute code before the first draw of a component. &nbsp;When this method is called the element for the associated component will already be part of the DOM. &nbsp;This makes this method an appropriate place to </span><span>add event listeners</span><sup><a href="#cmnt4" name="cmnt_ref4">[d]</a></sup><span>&nbsp;on DOM elements in the component or perform any other action that should only be performed once during a component&rsquo;s lifecycle.</span></p><p style="height:11pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span></span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="font-family:&quot;Courier New&quot;">childComponentWillPrepareForDraw(child)</span></p><p style="height:11pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="font-family:&quot;Courier New&quot;"></span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="font-family:&quot;Courier New&quot;">willDraw(timestamp)</span></p><p style="height:11pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span></span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="font-family:&quot;Courier New&quot;">draw(timestamp)</span></p><p style="height:11pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span></span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="font-family:&quot;Courier New&quot;">didDraw(timestamp)</span></p><p style="height:11pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="font-family:&quot;Courier New&quot;"></span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="text-decoration:line-through">Registered property descriptor addition</span></p><p style="height:11pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="text-decoration:line-through"></span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="text-decoration:line-through;font-family:&quot;Courier New&quot;">needsDraw</span><span style="text-decoration:line-through">&nbsp;</span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="text-decoration:line-through">property descriptor addition</span></p><h3 style="padding-left:0;padding-right:0;line-height:1.15;padding-top:14pt;color:#000000;text-align:left;direction:ltr;font-size:14pt;margin:0;font-family:&quot;Arial&quot;;font-weight:bold;padding-bottom:4pt"><a name="h.60rjnnccp5ma"></a><span>Examples</span></h3><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>Remove if unnecessary</span></p><h3 style="padding-left:0;padding-right:0;line-height:1.15;padding-top:14pt;color:#000000;text-align:left;direction:ltr;font-size:14pt;margin:0;font-family:&quot;Arial&quot;;font-weight:bold;padding-bottom:4pt"><a name="h.9qqs41sdkrcs"></a><span>Integration</span></h3><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>Remove if unnecessary</span></p><h3 style="padding-left:0;padding-right:0;line-height:1.15;padding-top:14pt;color:#000000;text-align:left;direction:ltr;font-size:14pt;margin:0;font-family:&quot;Arial&quot;;font-weight:bold;padding-bottom:4pt"><a name="h.iud7a9mdzn4"></a><span>Dependencies</span></h3><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>Remove if unnecessary</span></p><h3 style="padding-left:0;padding-right:0;line-height:1.15;padding-top:14pt;color:#000000;text-align:left;direction:ltr;font-size:14pt;margin:0;font-family:&quot;Arial&quot;;font-weight:bold;padding-bottom:4pt"><a name="h.178na9dwjesv"></a><span>Concerns</span></h3><ol start="1" style="list-style-type:disc;margin:0;padding:0"><li style="margin-right:0;color:#000000;direction:ltr;font-size:11pt;margin-left:36pt;margin-bottom:0;font-family:&quot;Arial&quot;;margin-top:0;padding:0"><span>With the current design ordering of draw calls between parents and children cannot be guaranteed [04/10/2012 Resolved: the list is now sorted to guarantee that child components draw before their parent component.]</span></li><li style="margin-right:0;color:#000000;direction:ltr;font-size:11pt;margin-left:36pt;margin-bottom:0;font-family:&quot;Arial&quot;;margin-top:0;padding:0"><span>Component hierarchy is lost when the list is flattened for drawing</span></li></ol><h3 style="padding-left:0;padding-right:0;line-height:1.15;padding-top:14pt;color:#000000;text-align:left;direction:ltr;font-size:14pt;margin:0;font-family:&quot;Arial&quot;;font-weight:bold;padding-bottom:4pt"><a name="h.a7jaldiklyym"></a><span>Up For Discussion</span></h3><ol start="1" style="list-style-type:disc;margin:0;padding:0"><li style="margin-right:0;color:#000000;direction:ltr;font-size:11pt;margin-left:36pt;margin-bottom:0;font-family:&quot;Arial&quot;;margin-top:0;padding:0"><span>The current design loses the hierarchy of components once the components that want to draw are flattened into a single list, what are the ways around this? &nbsp;Does there need to be a way around it?</span></li><li style="margin-right:0;color:#000000;direction:ltr;font-size:11pt;margin-left:36pt;margin-bottom:0;font-family:&quot;Arial&quot;;margin-top:0;padding:0"><span>Should drawing take place from root to leaf, or leaf to root? &nbsp;In some cases parents want to draw before their children, </span><span>for example a layout component that wants to set bounds for its children</span><sup><a href="#cmnt5" name="cmnt_ref5">[e]</a></sup><span>, and in other cases parents want to draw after their children, such as the flow component where the parent flow component has to make updates in its draw based on what its child repetition component has just drawn</span></li><li style="margin-right:0;color:#000000;direction:ltr;font-size:11pt;margin-left:36pt;margin-bottom:0;font-family:&quot;Arial&quot;;margin-top:0;padding:0"><span>The concept of having </span><span style="font-family:&quot;Courier New&quot;">needsDraw=true</span><span>&nbsp;in the </span><span style="font-family:&quot;Courier New&quot;">willDraw</span><span>&nbsp;adding the newly requested component to the currently executing draw was introduced before composers were implemented. &nbsp;Now that composers exist and are able to act before the </span><span style="font-family:&quot;Courier New&quot;">willDraw</span><span>&nbsp;calls are made should a </span><span style="font-family:&quot;Courier New&quot;">needsDraw</span><span>&nbsp;set in the </span><span style="font-family:&quot;Courier New&quot;">willDraw</span><span>&nbsp;schedule a new draw loop instead of adding the component to the currently executing loop? &nbsp;This will fix being able to guarantee the order of draw calls between parents and children during a loop.</span></li></ol><p style="height:11pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span></span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span style="font-weight:bold">Meeting Notes 04/04/2012</span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The draw cycle was discussed in a meeting with Javier, Jean-Fran&ccedil;ois, Fran&ccedil;ois, Afonso, Stuart, Kishore and Heather. &nbsp;The following decisions were made</span></p><p style="height:11pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span></span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. The component order for willDraw and didDraw is not important, but the order for draw is and it will be leaf to root, i.e. children draw before their parents.</span></p><p style="color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. The ability to schedule a component to draw as part of the currently executing cycle during the willDraw phase is necessary and worth the performance implications.</span></p><hr style="height:1px;width:33%"><div><p style="padding-left:0;padding-right:0;padding-top:0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding-bottom:10pt"><a href="#ftnt_ref1" name="ftnt1">[1]</a><span style="font-size:10pt">&nbsp;</span><span style="color:#1155cc;font-size:10pt;text-decoration:underline"><a href="https://lists.webkit.org/pipermail/webkit-dev/2012-February/019375.html" style="color:inherit;text-decoration:inherit">https://lists.webkit.org/pipermail/webkit-dev/2012-February/019375.html</a></span><span style="font-size:10pt">&nbsp;- Discussion of slow performance of Facebook timeline feature where it&rsquo;s decided that part of the slow performance is due to &ldquo;layout thrash&rdquo;</span></p></div><div style="margin:5px;border:1px solid black"><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><a href="#cmnt_ref1" name="cmnt1">[a]</a><span>wnpm38:</span></p><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>The &#39;offsetWidth&#39; example is often used in this discussion, and I was wondering if it&#39;s correct to say that any &quot;calculated property&quot; should only be read in willDraw/didDraw()? </span></p><p style="line-height:1.0;height:11pt;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span></span></p><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>In other words, is there any further guidance we can provide developers as to what DOM properties/methods should/should not be read outside of did/willDraw(). Or maybe there isn&#39;t a distinction to be made?</span></p></div><div style="margin:5px;border:1px solid black"><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><a href="#cmnt_ref2" name="cmnt2">[b]</a><span>wnpm38:</span></p><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>Does having this return false optimize performance at all ? For instance, say a component has lots of child components that don&#39;t ever get re-drawn (not sure when this would happen).</span></p><hr><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>gfj678:</span></p><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>Yes, this can improve performance. &nbsp;One example is the condition component. &nbsp;If the condition is false then the condition component can stop the drawing at its level without even exploring its children.</span></p></div><div style="margin:5px;border:1px solid black"><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><a href="#cmnt_ref3" name="cmnt3">[c]</a><span>wnpm38:</span></p><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>Does prepareForActivationEvents() get called at some point, too? Or perhaps that is called elsewhere.</span></p><hr><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>gfj678:</span></p><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>prepareForActivationEvents() gets called at a later point in time when the user initiates interaction through a mousedown or touchstart event.</span></p><hr><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>wnpm38:</span></p><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>Should pointer/touch event listeners only be set up in prepareForActivationEvents(), for performance purposes, rather than prepareForDraw()?</span></p><hr><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>gfj678:</span></p><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>Yes, prepareForActivationEvents was added for performance reasons so that the listeners would not be added if there was never any interaction.</span></p></div><div style="margin:5px;border:1px solid black"><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><a href="#cmnt_ref4" name="cmnt4">[d]</a><span>gfj678:</span></p><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>So, where is the symmetric call to remove event listeners?</span></p></div><div style="margin:5px;border:1px solid black"><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><a href="#cmnt_ref5" name="cmnt5">[e]</a><span>gfj678:</span></p><p style="line-height:1.0;color:#000000;direction:ltr;font-size:11pt;margin:0;font-family:&quot;Arial&quot;;padding:0"><span>Since no measurements should be made in draw is this more appropriate for willDraw?</span></p></div></body></html>